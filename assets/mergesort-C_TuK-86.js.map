{"version":3,"file":"mergesort-C_TuK-86.js","sources":["../../src/mergesort/array.ts","../../src/mergesort/sort.ts","../../src/mergesort/index.ts"],"sourcesContent":["export const peekFirst = <T>(arr: T[]) => {\n  // Get the first element of the array\n  const first = arr[0];\n\n  return first;\n};\n\nexport const removeFirst = <T>(arr: T[]): T | undefined => {\n  // Get the first element of the array\n  const first = arr[0];\n\n  // Delete the first element\n  delete arr[0];\n\n  return first;\n};\n\nexport const split = <T>(arr: T[], index: number): [T[], T[]] => {\n  // Check if the index is out of bounds\n  if (index < 0 || index >= arr.length) {\n    throw new Error(`Cannot split at ${index}: out of bounds`);\n  }\n\n  // Split the array into two halves\n  const left = arr.slice(0, index);\n  const right = arr.slice(index);\n\n  return [left, right];\n};\n","import { peekFirst, removeFirst, split } from \"./array\";\n\ntype Comparable = number | string | Date;\n\n/**\n * Sorts an array using the merge sort algorithm\n * @param arr the array to sort\n * @returns a new sorted array\n */\nconst mergeSort = (arr: Comparable[]): Comparable[] => {\n  // Base case: an array of 0 or 1 elements is already sorted\n  if (arr.length === 1) {\n    return arr;\n  }\n\n  // Calculate the center of the array\n  const center = Math.floor(arr.length / 2);\n\n  // Split the array into two halves\n  let [left, right] = split(arr, center);\n\n  // Recursively sort each half\n  left = mergeSort(left);\n  right = mergeSort(right);\n\n  // Merge the sorted halves\n  return merge(left, right);\n};\n\n/**\n * Merge two sorted arrays\n * @param left A sorted array\n * @param right A sorted array\n * @returns A new sorted array containing all elements from left and right\n */\nconst merge = <C extends Comparable>(left: C[], right: C[]): C[] => {\n  const results: C[] = [];\n\n  // While there are elements in both arrays\n  while (left.length && right.length) {\n    let smallest: C;\n\n    const leftFirst = peekFirst(left);\n    const rightFirst = peekFirst(right);\n\n    // Compare the first elements of each array\n    if (leftFirst <= rightFirst) {\n      smallest = removeFirst(left)!;\n    } else {\n      smallest = removeFirst(right)!;\n    }\n\n    // Add the smaller element to the results\n    results.push(smallest);\n  }\n\n  return [...results, ...left, ...right];\n};\n\nexport default mergeSort;\n","import sort from \"./sort\";\n\nconst N = 100;\nconst bigArray = Array.from({ length: N }, () => Math.round(Math.random() * N));\nconsole.log(\"Merge sort: %o\", sort(bigArray));"],"names":["peekFirst","arr","removeFirst","first","split","index","left","right","mergeSort","center","merge","results","smallest","leftFirst","rightFirst","N","bigArray","sort"],"mappings":"6CAAa,MAAAA,EAAgBC,GAEbA,EAAI,CAAC,EAKRC,EAAkBD,GAA4B,CAEnD,MAAAE,EAAQF,EAAI,CAAC,EAGnB,cAAOA,EAAI,CAAC,EAELE,CACT,EAEaC,EAAQ,CAAIH,EAAUI,IAA8B,CAE/D,GAAIA,EAAQ,GAAKA,GAASJ,EAAI,OAC5B,MAAM,IAAI,MAAM,mBAAmBI,CAAK,iBAAiB,EAI3D,MAAMC,EAAOL,EAAI,MAAM,EAAGI,CAAK,EACzBE,EAAQN,EAAI,MAAMI,CAAK,EAEtB,MAAA,CAACC,EAAMC,CAAK,CACrB,ECnBMC,EAAaP,GAAoC,CAEjD,GAAAA,EAAI,SAAW,EACV,OAAAA,EAIT,MAAMQ,EAAS,KAAK,MAAMR,EAAI,OAAS,CAAC,EAGxC,GAAI,CAACK,EAAMC,CAAK,EAAIH,EAAMH,EAAKQ,CAAM,EAGrC,OAAAH,EAAOE,EAAUF,CAAI,EACrBC,EAAQC,EAAUD,CAAK,EAGhBG,EAAMJ,EAAMC,CAAK,CAC1B,EAQMG,EAAQ,CAAuBJ,EAAWC,IAAoB,CAClE,MAAMI,EAAe,CAAC,EAGf,KAAAL,EAAK,QAAUC,EAAM,QAAQ,CAC9B,IAAAK,EAEE,MAAAC,EAAYb,EAAUM,CAAI,EAC1BQ,EAAad,EAAUO,CAAK,EAG9BM,GAAaC,EACfF,EAAWV,EAAYI,CAAI,EAE3BM,EAAWV,EAAYK,CAAK,EAI9BI,EAAQ,KAAKC,CAAQ,CAAA,CAGvB,MAAO,CAAC,GAAGD,EAAS,GAAGL,EAAM,GAAGC,CAAK,CACvC,ECvDMQ,EAAI,IACJC,EAAW,MAAM,KAAK,CAAE,OAAQD,CAAE,EAAG,IAAM,KAAK,MAAM,KAAK,OAAO,EAAIA,CAAC,CAAC,EAC9E,QAAQ,IAAI,iBAAkBE,EAAKD,CAAQ,CAAC"}